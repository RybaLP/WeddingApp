"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    parse: function() {
        return parse;
    },
    default: function() {
        return _default;
    }
});
var _pluginHelper = require("@bbob/plugin-helper");
var _lexer = require("./lexer");
var _utils = require("./utils");
/**
 * @public
 * @param {string} input
 * @param {Object} opts
 * @param {Function} opts.createTokenizer
 * @param {Array<string>} opts.onlyAllowTags
 * @param {Array<string>} opts.contextFreeTags
 * @param {Boolean} opts.enableEscapeTags
 * @param {string} opts.openTag
 * @param {string} opts.closeTag
 * @return {Array<string|TagNode>}
 */ var parse = function(input, opts) {
    if (opts === void 0) opts = {};
    var options = opts;
    var openTag = options.openTag || _pluginHelper.OPEN_BRAKET;
    var closeTag = options.closeTag || _pluginHelper.CLOSE_BRAKET;
    var onlyAllowTags = (options.onlyAllowTags || []).filter(Boolean).map(function(tag) {
        return tag.toLowerCase();
    });
    var tokenizer = null;
    /**
   * Result AST of nodes
   * @private
   * @type {NodeList}
   */ var nodes = (0, _utils.createList)();
    /**
   * Temp buffer of nodes that's nested to another node
   * @private
   * @type {NodeList}
   */ var nestedNodes = (0, _utils.createList)();
    /**
   * Temp buffer of nodes [tag..]...[/tag]
   * @private
   * @type {NodeList}
   */ var tagNodes = (0, _utils.createList)();
    /**
   * Temp buffer of tag attributes
   * @private
   * @type {NodeList}
   */ var tagNodesAttrName = (0, _utils.createList)();
    /**
   * Cache for nested tags checks
   * @type Set<string>
   */ var nestedTagsMap = new Set();
    /**
   * @param {Token} token
   * @returns {boolean}
   */ var isTokenNested = function(token) {
        var value = token.getValue();
        if (!nestedTagsMap.has(value) && tokenizer.isTokenNested && tokenizer.isTokenNested(token)) {
            nestedTagsMap.add(value);
            return true;
        }
        return nestedTagsMap.has(value);
    };
    /**
   * @private
   * @param {string} tagName
   * @returns {boolean}
   */ var isTagNested = function(tagName) {
        return Boolean(nestedTagsMap.has(tagName));
    };
    /**
   * @private
   * @param {string} value
   * @return {boolean}
   */ var isAllowedTag = function(value) {
        if (onlyAllowTags.length) {
            return onlyAllowTags.indexOf(value.toLowerCase()) >= 0;
        }
        return true;
    };
    /**
   * Flushes temp tag nodes and its attributes buffers
   * @private
   * @return {Array}
   */ var flushTagNodes = function() {
        if (tagNodes.flushLast()) {
            tagNodesAttrName.flushLast();
        }
    };
    /**
   * @private
   * @return {Array}
   */ var getNodes = function() {
        var lastNestedNode = nestedNodes.getLast();
        if (lastNestedNode && Array.isArray(lastNestedNode.content)) {
            return lastNestedNode.content;
        }
        return nodes.toArray();
    };
    /**
   * @private
   * @param {string|TagNode} node
   * @param {boolean} isNested
   */ var appendNodeAsString = function(node, isNested) {
        if (isNested === void 0) isNested = true;
        var items = getNodes();
        if (Array.isArray(items)) {
            items.push(node.toTagStart({
                openTag: openTag,
                closeTag: closeTag
            }));
            if (node.content.length) {
                node.content.forEach(function(item) {
                    items.push(item);
                });
                if (isNested) {
                    items.push(node.toTagEnd({
                        openTag: openTag,
                        closeTag: closeTag
                    }));
                }
            }
        }
    };
    /**
   * @private
   * @param {string|TagNode} node
   */ var appendNodes = function(node) {
        var items = getNodes();
        if (Array.isArray(items)) {
            if ((0, _pluginHelper.isTagNode)(node)) {
                if (isAllowedTag(node.tag)) {
                    items.push(node.toTagNode());
                } else {
                    appendNodeAsString(node);
                }
            } else {
                items.push(node);
            }
        }
    };
    /**
   * @private
   * @param {Token} token
   */ var handleTagStart = function(token) {
        flushTagNodes();
        var tagNode = _pluginHelper.TagNode.create(token.getValue());
        var isNested = isTokenNested(token);
        tagNodes.push(tagNode);
        if (isNested) {
            nestedNodes.push(tagNode);
        } else {
            appendNodes(tagNode, token);
        }
    };
    /**
   * @private
   * @param {Token} token
   */ var handleTagEnd = function(token) {
        flushTagNodes();
        var lastNestedNode = nestedNodes.flushLast();
        if (lastNestedNode) {
            appendNodes(lastNestedNode, token);
        } else if (typeof options.onError === "function") {
            var tag = token.getValue();
            var line = token.getLine();
            var column = token.getColumn();
            options.onError({
                message: "Inconsistent tag '" + tag + "' on line " + line + " and column " + column,
                tagName: tag,
                lineNumber: line,
                columnNumber: column
            });
        }
    };
    /**
   * @private
   * @param {Token} token
   */ var handleTag = function(token) {
        // [tag]
        if (token.isStart()) {
            handleTagStart(token);
        }
        // [/tag]
        if (token.isEnd()) {
            handleTagEnd(token);
        }
    };
    /**
   * @private
   * @param {Token} token
   */ var handleNode = function(token) {
        /**
     * @type {TagNode}
     */ var lastTagNode = tagNodes.getLast();
        var tokenValue = token.getValue();
        var isNested = isTagNested(token);
        if (lastTagNode) {
            if (token.isAttrName()) {
                tagNodesAttrName.push(tokenValue);
                lastTagNode.attr(tagNodesAttrName.getLast(), "");
            } else if (token.isAttrValue()) {
                var attrName = tagNodesAttrName.getLast();
                if (attrName) {
                    lastTagNode.attr(attrName, tokenValue);
                    tagNodesAttrName.flushLast();
                } else {
                    lastTagNode.attr(tokenValue, tokenValue);
                }
            } else if (token.isText()) {
                if (isNested) {
                    lastTagNode.append(tokenValue);
                } else {
                    appendNodes(tokenValue);
                }
            } else if (token.isTag()) {
                // if tag is not allowed, just past it as is
                appendNodes(token.toString());
            }
        } else if (token.isText()) {
            appendNodes(tokenValue);
        } else if (token.isTag()) {
            // if tag is not allowed, just past it as is
            appendNodes(token.toString());
        }
    };
    /**
   * @private
   * @param {Token} token
   */ var onToken = function(token) {
        if (token.isTag()) {
            handleTag(token);
        } else {
            handleNode(token);
        }
    };
    tokenizer = (opts.createTokenizer ? opts.createTokenizer : _lexer.createLexer)(input, {
        onToken: onToken,
        openTag: openTag,
        closeTag: closeTag,
        onlyAllowTags: options.onlyAllowTags,
        contextFreeTags: options.contextFreeTags,
        enableEscapeTags: options.enableEscapeTags
    });
    // eslint-disable-next-line no-unused-vars
    var tokens = tokenizer.tokenize();
    // handles situations where we open tag, but forgot close them
    // for ex [q]test[/q][u]some[/u][q]some [u]some[/u] // forgot to close [/q]
    // so we need to flush nested content to nodes array
    var lastNestedNode = nestedNodes.flushLast();
    if (lastNestedNode && isTagNested(lastNestedNode.tag)) {
        appendNodeAsString(lastNestedNode, false);
    }
    return nodes.toArray();
};
var _default = parse;
