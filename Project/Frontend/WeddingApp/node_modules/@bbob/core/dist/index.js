(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@bbob/parser')) :
    typeof define === 'function' && define.amd ? define(['exports', '@bbob/parser'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.BbobCore = {}, global.parser));
})(this, (function (exports, parser) { 'use strict';

    /* eslint-disable no-plusplus */ const isObj = (value)=>typeof value === 'object';
    const isBool = (value)=>typeof value === 'boolean';
    function iterate(t, cb) {
        const tree = t;
        if (Array.isArray(tree)) {
            for(let idx = 0; idx < tree.length; idx++){
                tree[idx] = iterate(cb(tree[idx]), cb);
            }
        } else if (tree && isObj(tree) && tree.content) {
            iterate(tree.content, cb);
        }
        return tree;
    }
    function same(expected, actual) {
        if (typeof expected !== typeof actual) {
            return false;
        }
        if (!isObj(expected) || expected === null) {
            return expected === actual;
        }
        if (Array.isArray(expected)) {
            return expected.every((exp)=>[].some.call(actual, (act)=>same(exp, act)));
        }
        return Object.keys(expected).every((key)=>{
            const ao = actual[key];
            const eo = expected[key];
            if (isObj(eo) && eo !== null && ao !== null) {
                return same(eo, ao);
            }
            if (isBool(eo)) {
                return eo !== (ao === null);
            }
            return ao === eo;
        });
    }
    function match(expression, cb) {
        return Array.isArray(expression) ? iterate(this, (node)=>{
            for(let idx = 0; idx < expression.length; idx++){
                if (same(expression[idx], node)) {
                    return cb(node);
                }
            }
            return node;
        }) : iterate(this, (node)=>same(expression, node) ? cb(node) : node);
    }

    function walk(cb) {
        return iterate(this, cb);
    }
    function bbob(plugs) {
        const plugins = typeof plugs === 'function' ? [
            plugs
        ] : plugs || [];
        let options = {
            skipParse: false
        };
        return {
            process (input, opts) {
                options = opts || {};
                const parseFn = options.parser || parser.parse;
                const renderFn = options.render;
                const data = options.data || null;
                if (typeof parseFn !== 'function') {
                    throw new Error('"parser" is not a function, please pass to "process(input, { parser })" right function');
                }
                let tree = options.skipParse ? input || [] : parseFn(input, options);
                // raw tree before modification with plugins
                const raw = tree;
                tree.messages = [];
                tree.options = options;
                tree.walk = walk;
                tree.match = match;
                plugins.forEach((plugin)=>{
                    tree = plugin(tree, {
                        parse: parseFn,
                        render: renderFn,
                        iterate,
                        match,
                        data
                    }) || tree;
                });
                return {
                    get html () {
                        if (typeof renderFn !== 'function') {
                            throw new Error('"render" function not defined, please pass to "process(input, { render })"');
                        }
                        return renderFn(tree, tree.options);
                    },
                    tree,
                    raw,
                    messages: tree.messages
                };
            }
        };
    }

    exports.default = bbob;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
